try:
    import sys,os
    sys.path.append(os.path.abspath("D:/DATA/GITHUB PROJECTS/DesktopVoiceAssistant-Cosmos/venv/Lib/site-packages"))
    print("running")
except Exception as e:
    print("only for vikas(pyaudio), change file",e)



import math
import time
import wave
import datetime
import pyaudio
import speech_recognition as sr
import pyttsx3
import webbrowser
import wikipedia
import random
import pyjokes
# import os
import struct
import numpy as np
import pygame
import tkinter as tk
from tkinter.filedialog import askopenfilename
import threading
from pygame import mixer
import pygame.gfxdraw
from vosk import Model, KaldiRecognizer
try:
    hasInternet = True
    import pywhatkit
except Exception as ee:
    hasInternet = (
        not str(ee) == 'Error while connecting to the Internet. Make sure you are connected to the Internet!'
    )



assistant = 'cosmos'
aliases = ['kosmos', "cosmo's"]
voice_type = 'm'
ttspeed = (180, 175)  # speed for male, female voice
user = ''
check_for = ''
debug_mode = True  # TODO should be False
running = False
noteing = ''
talking = ''
listener = None
mic = None
stop_listening = None
freq_lines = []
dLay = 0
ambience = 2.6
command_taken = "command_taken.wav"
output_given = "command_end.wav"
info_file_path = 'cosmos_assistant.txt'
tts_wav = 'cosmos_tts.wav'
version = '0.2.0'

# list of different greetings GG
greeting = ('How may I be of assistance.', 'How may I help.', 'How may I serve you today.')

# {trigger : (function to open file, path)}
programs = {'word': (os.startfile, "C:\\Program Files\\Microsoft Office\\root\\Office16\\WINWORD"),
            'powerpoint': (os.startfile, "C:\\Program Files\\Microsoft Office\\root\\Office16\\POWERPNT"),
            'excel': (os.startfile, "C:\\Program Files\\Microsoft Office\\root\\Office16\\EXCEL"),
            'browser': (os.startfile, "C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave"),
            'notepad': (os.system, 'notepad'),
            'calculator': (os.system, 'calc')
            }

# banter[i] = (   ( triggers ) ,  response    )
banter = [(('how are you', 'how have you been'),
           "I am an AI I don't have feelings, of course I am sure your doing great!"),
          (('how old are you', 'what is your age'),
           'Age is just a number and I transcend SPACE and TIME!'),
          (('hello', 'hai', 'hi', 'sup', 'morning', 'evening'),
           "Hello {}"),
          (('are an invalid command', 'i hate you'),
           'ouch that hurts')
          ]

# {trigger : response}
info = {
    'song': '{} play song blank to play you that song',
    'time': '{} what is the time to know the time',
    'joke': '{} tell me a joke to hear a joke',
    'calculator': '{} calculate expression to calculate an expression',
    'help': '{} help trigger to know what the trigger does\nthe triggers are\n'
            'song time joke calculator help open note dice random name question voice terminate',
    'open': '{} run blank to run any program on your computer',
    'note': '{0} write down or {0} transcribe or {0} note down to activate note taking\n'
            'click the screen to stop note taking',
    'dice': '{} roll a dice of n sides',
    'random': '{} select a random number between x and y',
    'question': 'you can ask me any doubts',
    'name': 'you can change my name by saying\n{0} change your name to blank\nyou can change your name by saying\n'
            '{0}change my name to blank',
    'voice': 'you can change my voice by saying\n{0} change your voice to male\nor\n{0} change your voice to female',
    'terminate': 'to terminate me just say:\n{0} terminate\nor\n{0} thank you\nor\n'
                 '{0} that is all\nor\n{0} stop listening\nor\n{0} quit\nor\n{0} close',
}

# {invalid_words : valid counterparts} #! all wrong
operators = {
    'a': '1', 'plus': '+', '+': '+', 'and': '+', 'minus': '-', '-': '-', 'into': '*', 'x': '*', '*': '*', 'times': '*',
    'by': '/', '/': '/', 'mod': '%', 'percent': '*0.01', 'power': '**', 'square': '**2', 'cube': '**3',
    'dot': '.', 'point': '.', '.': '.', 'hole': ')', 'root': '**(-1)', 'of': '*',
    'hundred': '0' * 2, 'thousand': '0' * 3, 'lakhs': '0' * 5, 'lakh': '0' * 5, 'lacs': '0' * 5, 'lac': '0' * 5,
    'crores': '0' * 7, 'crore': '0' * 7, 'million': '0' * 6, 'billion': '0' * 9, 'trillion': '0' * 12,
    'quadrillion': '0' * 15, 'quintillion': '0' * 18, 'sextillion': '0' * 21, 'septillion': '0' * 24,
    'octillion': '0' * 27, 'nonillion': '0' * 30, 'decillion': '0' * 33, 'undecillion': '0' * 36,
    'duodecillion': '0' * 39, 'tredecillion': '0' * 42, 'quattuordecillion': '0' * 45, 'quindecillion': '0' * 48,
    'sexdecillion': '0' * 51, 'septendecillion': '0' * 54, 'octodecillion': '0' * 57, 'novemdecillion': '0' * 60,
    'vigintillion': '0' * 63, 'googol': '0' * 100, 'centillion': '0' * 303
}

# helpful command [NON-CRITICAL]
def debug(*args, **kwargs):
    """if 'cosmos' is in debug mode, function prints the args, kwargs to the console"""
    if debug_mode:
        print(*args, **kwargs)

def play_tune(is_end=True):
    """plays the ending/beginning tune"""
    mixer.music.load((command_taken, output_given)[is_end])
    mixer.music.play()

def has(list1, *list2, check=any, isword=True):
    """creates a tuple of boolean values: True, if element in list2 is present in list1 else False
        and operates a given function on the iterable
        if isword=True, checks if the words in the string are present
        check=any, returns True if any item in the iterable is True else False
        check=all, returns True if all items in the iterable are True else False"""
    if is_str := type(list1) == str:
        list1 = f' {list1.strip()} '
    if isword and is_str and not any(type(i) != str for i in list2):
        list1 = list1.split()
    return check(i in list1 for i in list2)

def replace_all(text, *values, new_value="", isword=True):
    """removes all instances of values in the text with the new_value
        if isword=True, replaces only if the word is present and not the set of characters"""
    if isword:
        return ' '.join(map(lambda x: (x, new_value)[x in [i.strip() for i in values]], text.split()))
    for value in values:
        text = text.replace(value, new_value)
    return text


def talk(text, with_tune=True):
    """takes in text and says the text out loud,
        also return text"""
    debug("Output: ",text)
    
    global talking
    # can_talk = not bool(talking)
    # computer.save_to_file(text, tts_wav)
    # talking = True
    # # stop_listening(wait_for_stop=False)
    # for txt in text.split('\n'):  # gives a pause at a new line
    #     computer.say(talking := txt)
    #     if can_talk:
    #         computer.runAndWait()
    # # listen_in() /////////////////////////////////////////////////////////////
    talking = ''
    if with_tune:
        play_tune()
    return text

def speech_to_text():
    """makes cosmos listen in the background"""
    debug("Entering speech_to_text()")
    global vosk_model, vosk_mic, vosk_data, vosk_recognizer, vosk_stream, cosmos_listening
    vosk_model = Model(r'vosk-model-small-en-in-0.4')
    vosk_recognizer = KaldiRecognizer(vosk_model, 44100)

    vosk_mic = pyaudio.PyAudio()
    vosk_stream = vosk_mic.open(
        format=pyaudio.paInt16,
        channels=1,
        rate=44100,
        input=True,
        frames_per_buffer=4096, #! 8192
        output=True #! not there
    )
    vosk_stream.start_stream()

    while running:
        vosk_command = None
        vosk_data = vosk_stream.read(4096, exception_on_overflow = False)
        if vosk_recognizer.AcceptWaveform(vosk_data):
            debug("Waveform accepted:", end=" ")
            vosk_command = vosk_recognizer.Result()
            vosk_command = vosk_command[14:-3] #
            debug(vosk_command)
            run_command(vosk_command)
        debug(".", end='')

def run_command(command):
    """operates certain functions depending on the users' command"""
    # global assistant, user, check_for, voice_type, noteing

    # # checks if certain triggers are present in the command and gives an appropriate response
    # bantered = False
    # for value in banter:
    #     if has(command, *value[0], isword=False):
    #         talk(value[1].format(user), with_tune=False)
    #         command = replace_all(command, *value[0], isword=False)
    #         bantered = True
    # if bantered:
    #     return talk('')

    # # checks for a song to play
    # if has(command, 'play', 'song', check=all):
    #     debug(talk("Playing" + (song := replace_all(command, "play", "song"))))
    #     pywhatkit.playonyt(song)

    # # checks if the time is requested
    # elif 'time' in command and has(command, 'what is ', "what's ", 'tell ', isword=False):
    #     debug(talk('The time is ' + datetime.datetime.now().strftime('%I:%M %p')))

    # checks if a doubt is queried #* Working
    if has(command, 'search', 'who', 'what', 'when', 'how', 'why'):
        search = replace_all(command, *'search what who is was will did about how for when'.split())
        talk("Searching about " + search, with_tune=False)
        webbrowser.open("https://www.google.com/search?q=" + search)
        if has(command, 'who is ', 'what is ', 'who are ', 'when was ', isword=False):
            try:
                talk(wikipedia.summary(search, 1), with_tune=False)
            except wikipedia.exceptions.DisambiguationError as e:
                debug(e, ": No Info on Search...\n Opening Google")
            except wikipedia.exceptions.PageError as e:
                debug(e, ": No Info on search...\n Opening Google")
            except Exception as e:
                debug(e)
        play_tune()

    # # tells a joke
    # elif has(command, 'tell', 'joke', check=all):
    #     debug(talk(pyjokes.get_joke()))

    # # rolls a n-sided dice and gives the outcome
    # elif has(command := command.replace('dice', 'die'), 'roll', 'die', check=all):
    #     is_num = False
    #     for i in command.split():
    #         if i.isnumeric():
    #             talk(f'The {i} sided dice landed on {random.randint(1, int(i))}')
    #             is_num = True
    #             break
    #     if not is_num:
    #         talk(f'The dice landed on {random.randint(1, 6)}')

    # # Selects a random number within range
    # elif has(command, 'random', 'number', check=all):
    #     rng = [int(i) for i in command.split() if not i.isalpha()][:2]
    #     talk(f'Okay, The random number is: {random.randint(min(rng), max(rng))}')

    # # opens/runs the requested program
    # elif has(command, 'open', 'run'):
    #     command = replace_all(
    #         replace_all(command, 'open', 'run').replace('world', 'word'), *'google chrome web brave'.split(),
    #         new_value='browser')
    #     if has(command, *programs.keys()):
    #         for prog in list(set(programs.keys()) & set(command.split())):
    #             talk(f'Opening {prog}')
    #             programs[prog][0](programs[prog][1])
    #     else:
    #         # open a file and accept key=keyword/callword:value=path
    #         tk.Tk().withdraw()
    #         if prog_path := askopenfilename():
    #             with open(info_file_path, 'a') as info_file:
    #                 command = replace_all(command, *programs.keys())
    #                 info_file.write(f'\n{(trigger := command.split()[0])}:{prog_path}')
    #             programs[trigger] = (os.startfile, prog_path)
    #             os.startfile(prog_path)

    # # takes down notes for you #! FIX
    # # elif has(command, 'transcribe', 'note', 'write', 'right'):
    # #     noteing = f"Cosmos_notes{datetime.datetime.now().strftime('%H_%M_%S_%f %d-%m-%Y')}.txt"
    # #     talk('I have started Transcribing')
    # #     stop_listening(wait_for_stop=False)
    # #     listen_in(transcribe)

    # # changes either assistants's or user's name
    # elif has(command, 'change', 'name', check=all):
    #     typ = [assistant, user]
    #     typ_name = ('your', 'my', 'assistant', 'user')
    #     if not has(command, *typ_name):
    #         return talk(f"I am sorry, I do not know whose name to change\n{info['name'].format(assistant)}")
    #     is_user = has(command, typ_name[1], typ_name[3])
    #     command = replace_all(command, 'change', 'name', 'to', *typ_name).strip()
    #     talk(f"Would you like {typ_name[not is_user]} name to change from {typ[is_user]} to {command}")
    #     check_for = f'y/n{int(is_user)}{command}'
    #     while check_for:
    #         time.sleep(1)
    #     typ = [assistant, user]
    #     talk(f"{typ_name[not is_user].capitalize()} name is set to {(typ[is_user])}")
    #     # editting line 2 or 3 of the ifo_file using a temporary file
    #     with open(info_file_path) as info_file:
    #         with open(f'{info_file_path[:-4]}_temp_delete.txt', 'w') as temp_file:
    #             for i, line in enumerate(info_file):
    #                 temp_file.write(f'{typ_name[2 + is_user]}:{typ[is_user]}\n' if i == (1 + is_user) else line)
    #     os.remove(info_file_path)
    #     os.rename(f'{info_file_path[:-4]}_temp_delete.txt', info_file_path)

    # # changes Voice
    # elif has(command, 'change', 'voice', check=all):
    #     typ = replace_all(replace_all(command, 'change', 'voice', 'your', 'to'),
    #                       'mail', 'male', new_value='m').replace('female', 'f')
    #     if typ in ('m', 'f'):
    #         computer.setProperty('voice', tts_voice[(is_female := typ == 'f')].id)
    #         computer.setProperty("rate", ttspeed[(is_female := typ == 'f')])
    #         with open(info_file_path) as info_file:
    #             with open(f'{info_file_path[:-4]}_temp_delete.txt', 'w') as temp_file:
    #                 for i, line in enumerate(info_file):
    #                     temp_file.write(f'voice:{(voice_type := ("m", "f")[is_female])}\n' if i == 4 else line)
    #         os.remove(info_file_path)
    #         os.rename(f'{info_file_path[:-4]}_temp_delete.txt', info_file_path)
    #         talk('hello, This is the sound of my voice')
    #     else:
    #         talk(f"I am sorry, I do not know which voice to change to\n{info['voice'].format(assistant)}")

    # # evaluates a simple expression #! FIX
    # # elif has(command, 'calculate', 'evaluate'):
    # #     command = replace_all(command, 'calculate', 'evaluate', 'expression', 'the')
    # #     command = command.replace('whole', 'hole').replace('squared', 'square').replace('cubed', 'cube').strip()
    # #     elems = command.split()
    # #     i = 0
    # #     while i < len(elems):
    # #         debug(elems)
    # #         if not (val := operators.get(elems[i])) and elems[i].isalpha():
    # #             elems.pop(i)
    # #         else:
    # #             elems[i] = val if val else elems[i].replace('%', '*0.01')
    # #             i += 1
    # #     command = ''.join(elems)
    # #     command = '(' * (command.count(')')-command.count('(')) + command.replace('***', '**')
    # #     try:
    # #         debug(command, '=', talk(str(eval(command))))
    # #     except Exception as e:
    # #         debug(talk(str(e)))

    # # tells the user the commands and their Syntax
    # elif has(command, 'help'):
    #     talk('hey, did you know that you can ask me questions like', with_tune=False)
    #     if not len(triggers := set(command.replace('help', '', 1).split()) & set(info.keys())):
    #         triggers = info.keys()
    #     for trigger in triggers:
    #         talk(info[trigger].format(assistant), with_tune=False)
    #     talk("but remember to always say my name otherwise it doesn't count")

    # # checks if cosmos is called with an invalid command
    # elif running:
    #     talk(f'{command} is an invalid command')


def startup():
    """runs the program"""
    global running, assistant, user, aliases, voice_type,vosk_model,vosk_recognizer, vosk_mic, vosk_stream
    
    mixer.init()
    computer = pyttsx3.init()
    tts_voice = computer.getProperty('voices')

    running = True


    speech_to_text()


if __name__ == '__main__':
    startup()
